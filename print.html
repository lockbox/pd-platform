<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>pd-platform</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Overview.html">Introduction</a></li><li class="chapter-item expanded "><a href="binary/index.html"><strong aria-hidden="true">1.</strong> Game Binary Internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="binary/GameOfLife.html"><strong aria-hidden="true">1.1.</strong> Game of Life, at a Glance</a></li><li class="chapter-item expanded "><a href="binary/Building.html"><strong aria-hidden="true">1.2.</strong> Building Life</a></li><li class="chapter-item expanded "><a href="binary/BinaryStructure.html"><strong aria-hidden="true">1.3.</strong> Binary Structure</a></li></ol></li><li class="chapter-item expanded "><a href="console/index.html"><strong aria-hidden="true">2.</strong> Game Console</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="console/ValidMemory.html"><strong aria-hidden="true">2.1.</strong> Valid Memory</a></li><li class="chapter-item expanded "><a href="console/peripherals.html"><strong aria-hidden="true">2.2.</strong> Connected Peripherals</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Game Console Overview</div></li></ol></li><li class="chapter-item expanded "><a href="pdOS/index.html"><strong aria-hidden="true">3.</strong> pd-OS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pdOS/DumpingFlash.html"><strong aria-hidden="true">3.1.</strong> Dumping what flash we can</a></li><li class="chapter-item expanded "><a href="pdOS/TriagingUserFlashDump.html"><strong aria-hidden="true">3.2.</strong> Triaging User Mode flash dump</a></li><li class="chapter-item expanded "><a href="pdOS/SearchingForFreeRTOSCode.html"><strong aria-hidden="true">3.3.</strong> Searching for FreeRTOS code</a></li></ol></li><li class="chapter-item expanded "><a href="errata/index.html"><strong aria-hidden="true">4.</strong> Errata</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="errata/TriagingHardFloatDisassmbly.html"><strong aria-hidden="true">4.1.</strong> Triaging Hard Float Disassembly</a></li><li class="chapter-item expanded "><a href="errata/FPv5MeetWorld.html"><strong aria-hidden="true">4.2.</strong> FPv5 meets Worl</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pd-platform</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lockbox/pd-platform" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This aims to delve into the actual play.date console platform itself, including
(but not limited to) the game build process, the onboard operating system, and
the peripherals on board the console, the things with no existing documentation.</p>
<p>Note that any code marked as <code>Example Code</code> (such as, but not limited to the
<code>Game of Life</code> C example) or stated to be provided in the SDK or constructed by
Panic Inc. has sole IP ownership by Panic Inc. and belongs to them.</p>
<h2 id="previous-work"><a class="header" href="#previous-work">Previous Work</a></h2>
<p>Most of the past work has been focused on the API, the overal structure of the
packaged game files, and the soundtracks, not too much has been focused on
platform introspection itself. At a high level a lot of the work is already laid
out for us a la <a href="https://github.com/jaames/playdate-reverse-engineering">play.date reversing</a>,
but the things it ignores - the underlying runtime, the api for the game binaries
themselves, and how the play.date <em>is</em> the play.date. That still needs to be
uncovered.</p>
<p>Also i want a web browser on it lol.</p>
<h2 id="is-any-of-this-even-allowed"><a class="header" href="#is-any-of-this-even-allowed">Is any of this even allowed?</a></h2>
<p>Yeah basically.</p>
<p>The big &quot;don't&quot;'s of the SDK license are:</p>
<pre><code>You will not:
    - Modify, disassemble, or decompile any part of the SDK;
    - Distribute or transfer the SDK to others (other than the incorporation of distributable elements of the SDK in Your Developed Programs in accordance with the terms of this Agreement);
    - Modify, adapt, alter, translate, or incorporate into or with other software or create a derivative work of any part of the SDK, except as permitted herein, without express written permission from Panic;
    - Use the SDK to develop applications for other platforms or to develop another SDK, without express written permission from Panic.
</code></pre>
<p>The other fun one not in the initial bullets:</p>
<blockquote>
<p>&quot;[You will not] Use the SDK to create, develop, or use any program, software, or service which (1) contains any viruses, Trojan horses, worms, or other computer programming routines that are intended to damage, detrimentally interfere with, surreptitiously intercept, or expropriate any system, data, or personal information; (2) when used in the manner in which it is intended, violates any applicable law, statute, ordinance, or regulation (including without limitation the laws and regulations governing export control, unfair competition, anti-discrimination, false advertising, or data privacy); (3) infringes the intellectual property rights of third parties; or (4) interferes with the operability of other Panic or third-party programs or software; &quot;</p>
</blockquote>
<h3 id="addressing-the-donts"><a class="header" href="#addressing-the-donts">Addressing the <code>don't</code>'s</a></h3>
<ul>
<li>No changes are being made to the SDK, theres nothing of interest in the SDK to disassemble or decompile (the only things we could would be <code>pdutils</code> and <code>pdc</code>).</li>
<li>The SDK is not being redistributed so othing to worry about</li>
<li>The SDK is not being modified</li>
<li>The SDK is not being used to develop for another platform or &quot;develop another SDK&quot;</li>
<li>not doing any of that illegal stuff</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-binary-internals"><a class="header" href="#game-binary-internals">Game Binary Internals</a></h1>
<p>This gives a brief overview of what an example project setup could look like,
what the build process for the project is, and what the emitted binary structure
is. This focuses on what builds with the C SDK look like, and does not address lua
at all.</p>
<p>NOTE:</p>
<blockquote>
<p>This uses the <code>C_API/Examples/Life</code> example from the SDK extensively.</p>
</blockquote>
<ul>
<li><a href="binary/./GameOfLife.html">Game of Life</a></li>
<li><a href="binary/./Building.html">Building</a></li>
<li><a href="binary/./BinaryStructure.html">Binary Structure</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-game-of-life"><a class="header" href="#a-game-of-life">A Game of Life</a></h1>
<p>This is going to to a quick &quot;once over&quot; of the code they gave as example
for <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's Game of Life</a>.
<code>Life</code> is a classic nerd example and is fairly straghforward.</p>
<p>This is more concerned with the actual effect of the code layout as opposed to the
code itself.</p>
<p>The initial file strucure of <code>Life</code> looks like:</p>
<pre><code class="language-bash">$ tree
CMakeLists.txt
main.c
Makefile
Source/
  - pdxinfo
</code></pre>
<p>We can basically ignore the pdxinfo for now, and the Makefile as well. CMake is more powerful than Make and allows for cleaner builds imo and its easier to decipher wtf is actually going on so we'll look at CMakeLists.txt.</p>
<p>Note the lines:</p>
<pre><code class="language-cmake">if (TOOLCHAIN STREQUAL &quot;armgcc&quot;)
	add_executable(${PLAYDATE_GAME_DEVICE} ${SDK}/C_API/buildsupport/setup.c main.c)
else()
	add_library(${PLAYDATE_GAME_NAME} SHARED main.c )
endif()

include(${SDK}/C_API/buildsupport/playdate_game.cmake)
</code></pre>
<p>As we're focusing on binaries for the actual device we don't actually care about the else branch.</p>
<h2 id="input-files"><a class="header" href="#input-files">Input files</a></h2>
<p>The input compilation units to this game are going to be:</p>
<ul>
<li>setup.c (provided by SDK)</li>
<li>main.c (from user code)</li>
</ul>
<h3 id="mainc"><a class="header" href="#mainc"><code>main.c</code></a></h3>
<p>What main does in general is entirely up to the user, but <a href="https://sdk.play.date/1.12.3/Inside%20Playdate%20with%20C.html#_game_initialization">as per the docs</a>, must contain, at a minimum:</p>
<ul>
<li>overwrite <a href="https://sdk.play.date/1.12.3/Inside%20Playdate%20with%20C.html#f-system.setUpdateCallback"><code>playdate-&gt;system-&gt;setUpdateCallback()</code></a> for the pure C project.</li>
<li>implement <code>eventHandler()</code></li>
</ul>
<h3 id="what-is-setupc"><a class="header" href="#what-is-setupc">what is <code>setup.c</code>?</a></h3>
<p>This is where a lot of the play.date <em>magic</em> happens, and is a file provided in the SDK.
At a high level it is putting a more accessible name of their allocator in scope, and making wrappers around <code>malloc()</code>, <code>free()</code>,
and <code>realloc()</code>. Then is arranging the sections in the compilation unit so that the entry to
your defined code is always in the same place. This simplifies their API to all games and
is a really cool API decision on their part.</p>
<p>So how do they do all of this?</p>
<p>With *code*:</p>
<pre><code class="language-c">PDEventHandler* PD_eventHandler __attribute__((section(&quot;.capi_handler&quot;))) = &amp;eventHandlerShim;

extern uint32_t bssStart asm(&quot;__bss_start__&quot;);
uint32_t* _bss_start __attribute__((section(&quot;.bss_start&quot;))) = &amp;bssStart;

extern uint32_t bssEnd asm(&quot;__bss_end__&quot;);
uint32_t* _bss_end __attribute__((section(&quot;.bss_end&quot;))) = &amp;bssEnd;
</code></pre>
<h3 id="capi_handler"><a class="header" href="#capi_handler"><code>.capi_handler</code></a></h3>
<p><code>bss</code> okay cool thats standard <code>C</code> programming stuff (initialized 0 memory),
but what is <code>.capi_handler</code>??? According to OpenAI's ChatGPT:</p>
<pre><code>The .capi_handler section is a section of memory in a program that is reserved for storing data related to C++ exception handling. This data is used by the C++ runtime library to implement the C++ exception handling mechanism.

In a C++ program, when an exception is thrown, the exception object is passed to the C++ runtime library, which searches for an exception handler that is capable of handling the exception. The runtime library uses the data stored in the .capi_handler section to determine which exception handlers are available and how to invoke them.

The .capi_handler section is created by the linker when it links a C++ program. The linker generates the .capi_handler section based on information in the object files generated by the compiler.
</code></pre>
<p>Cool, so it sounds like they took advantage of the fact that the input code is only <code>C</code>, then
threw a pointer to the event handler in a section that would otherwise be unpopulated.</p>
<p>But what is the thing they are putting in that section? <code>eventHandlerShim()</code> is not a user
function.</p>
<p>Shim code:</p>
<pre><code class="language-c">int eventHandlerShim(PlaydateAPI* playdate, PDSystemEvent event, uint32_t arg)
{
	if ( event == kEventInit )
		pdrealloc = playdate-&gt;system-&gt;realloc;
	
	return eventHandler(playdate, event, arg);
}
</code></pre>
<p>The shim makes sure that the allocator pointer is headed to the right place before any user game
code executes. This is a pretty nice extra layer of developer nicities for us in that there is
one less thing to worry about (the <code>pdrealloc</code> is used in their helper <code>malloc()</code>, <code>free()</code>,
<code>realloc()</code>, implementations).</p>
<h3 id="bss"><a class="header" href="#bss"><code>.bss</code></a></h3>
<p>Also remember that in the <code>setup.c</code> they make a point to put a pointer to the <code>__bss_start__</code>
and <code>__bss_end__</code> addresses in their own sections, so now we are up to 3 custom sections going
into the actual build step (in addition to the default <code>.text</code>, <code>.data</code> etc).</p>
<p>So how is this going to look when it actually builds?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>NOTE:</p>
<blockquote>
<p>Building binaries using their device / arm SDK requires some dependencies. The only things i needed to install were: apt install arm-none-eabi-binutils, and snap install cmake since the apt version is wildly out of date.</p>
</blockquote>
<p>Assuming all the dependencies are installed and everything is setup correctly you should be able
to build the SDK's <code>Life</code> example and it should <em>just work</em>, note that you need to override the
defult toolchain file for cmake, see the below commands for more.</p>
<p>We're going to run the build commands, then dissect what's going on under the hood from all
the automagic stuffs we're given from Panic Inc. ( the automagic stuff is great btw &lt;3 ).</p>
<h2 id="running-the-build"><a class="header" href="#running-the-build">Running the Build</a></h2>
<p>Without any of the build output here are the types of commands needed to build an actual project, nothing more than your standard cmake build.</p>
<pre><code class="language-bash"># run from within the `Life` project directory
$ mkdir build &amp;&amp; cd build
# run the initial cmake build setup step, and override the toolchain
$ PLAYDATE_SDK_PATH=~/d/o/play.date/sdk-1.12.3 cmake .. -DCMAKE_TOOLCHAIN_FILE=~/d/o/play.date/sdk-1.12.3/C_API/buildsupport/arm.cmake
# build it, not sure if you need to provide the sdk path but i did anyways
$ PLAYDATE_SDK_PATH=~/d/o/play.date/sdk-1.12.3 make Life_DEVICE
</code></pre>
<p>Again, except with output</p>
<pre><code class="language-bash"># prep the build
$ pwd
[..]/sdk-1.12.3/C_API/Examples/Life
$ mkdir build &amp;&amp; cd build
$ PLAYDATE_SDK_PATH=~/d/o/play.date/sdk-1.12.3 cmake .. -DCMAKE_TOOLCHAIN_FILE=~/d/o/play.date/sdk-1.12.3/C_API/buildsupport/arm.cmake
-- arm.cmake loaded
-- arm.cmake loaded
-- The C compiler identification is GNU 8.3.1
-- The ASM compiler identification is GNU
-- Found assembler: /usr/bin/arm-none-eabi-gcc
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/arm-none-eabi-gcc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- SDK Path: /home/lockbox/d/o/play.date/sdk-1.12.3
-- Configuring done
-- Generating done
-- Build files have been written to: /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build

# do the build
$ PLAYDATE_SDK_PATH=~/d/o/play.date/sdk-1.12.3 make Life_DEVICE
/snap/cmake/1210/bin/cmake -S/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life -B/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build --check-build-system CMakeFiles/Makefile.cmake 0
make  -f CMakeFiles/Makefile2 Life_DEVICE
make[1]: Entering directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
/snap/cmake/1210/bin/cmake -S/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life -B/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build --check-build-system CMakeFiles/Makefile.cmake 0
/snap/cmake/1210/bin/cmake -E cmake_progress_start /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build/CMakeFiles 3
make  -f CMakeFiles/Makefile2 CMakeFiles/Life_DEVICE.dir/all
make[2]: Entering directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
make  -f CMakeFiles/Life_DEVICE.dir/build.make CMakeFiles/Life_DEVICE.dir/depend
make[3]: Entering directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
cd /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build &amp;&amp; /snap/cmake/1210/bin/cmake -E cmake_depends &quot;Unix Makefiles&quot; /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build/CMakeFiles/Life_DEVICE.dir/DependInfo.cmake --color=
make[3]: Leaving directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
make  -f CMakeFiles/Life_DEVICE.dir/build.make CMakeFiles/Life_DEVICE.dir/build
make[3]: Entering directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
[ 33%] Building C object CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj
/usr/bin/arm-none-eabi-gcc -DTARGET_EXTENSION=1 -DTARGET_PLAYDATE=1 -I/home/lockbox/d/o/play.date/sdk-1.12.3/C_API -Wall -Wno-unknown-pragmas -Wdouble-promotion -mthumb -mcpu=cortex-m7 -mfloat-abi=hard -mfpu=fpv5-sp-d16 -D__FPU_USED=1 -falign-functions=16 -fomit-frame-pointer -gdwarf-2 -fverbose-asm -ffunction-sections -fdata-sections -std=gnu11 -MD -MT CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj -MF CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj.d -o CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj -c /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c
[ 66%] Building C object CMakeFiles/Life_DEVICE.dir/main.c.obj
/usr/bin/arm-none-eabi-gcc -DTARGET_EXTENSION=1 -DTARGET_PLAYDATE=1 -I/home/lockbox/d/o/play.date/sdk-1.12.3/C_API -Wall -Wno-unknown-pragmas -Wdouble-promotion -mthumb -mcpu=cortex-m7 -mfloat-abi=hard -mfpu=fpv5-sp-d16 -D__FPU_USED=1 -falign-functions=16 -fomit-frame-pointer -gdwarf-2 -fverbose-asm -ffunction-sections -fdata-sections -std=gnu11 -MD -MT CMakeFiles/Life_DEVICE.dir/main.c.obj -MF CMakeFiles/Life_DEVICE.dir/main.c.obj.d -o CMakeFiles/Life_DEVICE.dir/main.c.obj -c /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/main.c
[100%] Linking C executable Life_DEVICE.elf
/snap/cmake/1210/bin/cmake -E cmake_link_script CMakeFiles/Life_DEVICE.dir/link.txt --verbose=1
/usr/bin/arm-none-eabi-gcc -mthumb -mcpu=cortex-m7 -mfloat-abi=hard -mfpu=fpv5-sp-d16 -D__FPU_USED=1 -T/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/link_map.ld -Wl,-Map=game.map,--cref,--gc-sections,--no-warn-mismatch &quot;CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj&quot; CMakeFiles/Life_DEVICE.dir/main.c.obj -o Life_DEVICE.elf
/usr/bin/arm-none-eabi-objcopy -Obinary Life_DEVICE.elf /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/Source/pdex.bin
cd /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life &amp;&amp; /home/lockbox/d/o/play.date/sdk-1.12.3/bin/pdc -sdkpath /home/lockbox/d/o/play.date/sdk-1.12.3 Source Life.pdx
make[3]: Leaving directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
[100%] Built target Life_DEVICE
make[2]: Leaving directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
/snap/cmake/1210/bin/cmake -E cmake_progress_start /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build/CMakeFiles 0
make[1]: Leaving directory '/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/build'
</code></pre>
<h1 id="examining-the-internal-cmake-files"><a class="header" href="#examining-the-internal-cmake-files">Examining the internal <code>CMake</code> files</a></h1>
<p>&lt;todo - not really super important, understanding them just makes things less automagic&gt;</p>
<h1 id="build-steps"><a class="header" href="#build-steps">Build Steps</a></h1>
<h2 id="build-setupc--mainc"><a class="header" href="#build-setupc--mainc">Build <code>setup.c</code> + <code>main.c</code></a></h2>
<p>This step is only one (ridiculous) gcc invocation, note that for each step (<code>setup.c</code> and <code>main.c</code>,
and any other compilation unit), the flags are the same unless manually changed:</p>
<pre><code class="language-bash"># prettified
/usr/bin/arm-none-eabi-gcc \
    -DTARGET_EXTENSION=1 \
    -DTARGET_PLAYDATE=1 \
    -I/home/lockbox/d/o/play.date/sdk-1.12.3/C_API \
    -Wall \
    -Wno-unknown-pragmas \
    -Wdouble-promotion \
    -mthumb \
    -mcpu=cortex-m7 \
    -mfloat-abi=hard \
    -mfpu=fpv5-sp-d16 \
    -D__FPU_USED=1 \
    -falign-functions=16 \
    -fomit-frame-pointer \
    -gdwarf-2 \
    -fverbose-asm \
    -ffunction-sections \
    -fdata-sections \
    -std=gnu11 \
    -MD \
    -MT CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj \
    -MF CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj.d \
    -o CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj \
    -c /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c
</code></pre>
<h3 id="deciphering-the-gcc-options-they-used"><a class="header" href="#deciphering-the-gcc-options-they-used">Deciphering the <code>gcc</code> options they used</a></h3>
<p>references:</p>
<ul>
<li>https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html</li>
<li>https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html</li>
<li>gcc manpage</li>
<li><a href="https://www.st.com/resource/en/reference_manual/dm00124865-stm32f75xxx-and-stm32f74xxx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf">processor manual</a></li>
<li>https://stackoverflow.com/questions/4274804/query-on-ffunction-section-fdata-sections-options-of-gcc
<ul>
<li>I'm curious what decisions drove them to do this, their results is some jank
form of PIC with a bunch of extra data they don't need?</li>
</ul>
</li>
</ul>
<table><thead><tr><th>Option</th><th>What it's doing</th></tr></thead><tbody>
<tr><td>-DTARGET_EXTENSION=1</td><td>Custom define for some of the CMake build system</td></tr>
<tr><td>-DTARGET_PLAYDATE=1</td><td>Custom define for some of the CMake build system</td></tr>
<tr><td>-I/home/lockbox/d/o/play.date/sdk-1.12.3/C_API</td><td>Add the <code>C_API</code> to the include path</td></tr>
<tr><td>-Wall</td><td>Warn against all the common stuff</td></tr>
<tr><td>-Wno-unknown-pragmas</td><td>manually disable <code>unknown-pragmas</code> since <code>-Wall</code> enables it</td></tr>
<tr><td>-Wdouble-promotion</td><td>enable <code>double-promotion</code> warning</td></tr>
<tr><td>-mthumb</td><td>emit thumb code</td></tr>
<tr><td>-mcpu=cortex-m7</td><td>select cpu</td></tr>
<tr><td>-mfloat-abi=hard</td><td>enable hard float support</td></tr>
<tr><td>-mfpu=fpv5-sp-d16</td><td>select the target FPU</td></tr>
<tr><td>-D__FPU_USED=1</td><td>Define intrinsic variable for FPU support</td></tr>
<tr><td>-falign-functions=16</td><td>Align functions to 16 bytes, (as per cpu docs)</td></tr>
<tr><td>-fomit-frame-pointer</td><td>Only use frame pointers when necessary (generally non-small functions)</td></tr>
<tr><td>-gdwarf-2</td><td>use dwarf2 debug info</td></tr>
<tr><td>-fverbose-asm</td><td>add extra &quot;readability&quot; syntax to generated asm, shouldnt be used? gross.</td></tr>
<tr><td>-ffunction-sections</td><td>Place each function in it's own section</td></tr>
<tr><td>-fdata-sections</td><td>Place each data item in it's own section</td></tr>
<tr><td>-std=gnu11</td><td>Set compiler standard</td></tr>
<tr><td>-MD -MT CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj</td><td>preprocessor arg</td></tr>
<tr><td>-MF CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj.d</td><td>preprocessor arg</td></tr>
<tr><td>-o CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj</td><td>output object file</td></tr>
<tr><td>-c /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c</td><td>input file to compile</td></tr>
</tbody></table>
<h1 id="link-step"><a class="header" href="#link-step">Link Step</a></h1>
<p>Now the fun part - the link step.</p>
<pre><code class="language-bash">/usr/bin/arm-none-eabi-gcc \
    -mthumb \
    -mcpu=cortex-m7 \
    -mfloat-abi=hard \
    -mfpu=fpv5-sp-d16 \
    -D__FPU_USED=1 \
    -T/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/link_map.ld \
        -Wl,-Map=game.map,--cref,--gc-sections,--no-warn-mismatch \
    &quot;CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj&quot; \
    CMakeFiles/Life_DEVICE.dir/main.c.obj \
    -o Life_DEVICE.elf
</code></pre>
<p>Many of the options are similar to the above build commands, the new flags however, are 
parameters to pass to the linker.</p>
<p>References:</p>
<ul>
<li>https://sourceware.org/binutils/docs/ld.html</li>
</ul>
<table><thead><tr><th>Linker Options</th><th>Effect</th></tr></thead><tbody>
<tr><td>-Tlink_map.ld</td><td>use <code>link_map.ld</code> as the linker script</td></tr>
<tr><td>-Map=game.map</td><td>output map to file <code>game.map</code></td></tr>
<tr><td>--cref</td><td>print symbol cross reference information to the map file</td></tr>
<tr><td>--gc-sections</td><td>link-tme section garbage collection</td></tr>
<tr><td>--no-warn-mismatch</td><td>ignore errors from linking mismatched objects</td></tr>
</tbody></table>
<p>Quote from <code>ld</code> documentation:</p>
<blockquote>
<p>3.6.4.4 Input Section and Garbage Collection
When link-time garbage collection is in use (‘--gc-sections’), it is often useful to mark sections that should not be eliminated. This is accomplished by surrounding an input section’s wildcard entry with KEEP(), as in KEEP(*(.init)) or KEEP(SORT_BY_NAME(*)(.ctors)).</p>
</blockquote>
<h3 id="what-this-is-doing"><a class="header" href="#what-this-is-doing">What this is doing</a></h3>
<p>The output symbol / section map for <code>Life_DEVICE.elf</code> is getting dumped to <code>game.map</code>, so now
we can retroactively figure out what things are at x offset into memory etc.</p>
<h2 id="parsing-link_mapld"><a class="header" href="#parsing-link_mapld">Parsing <code>link_map.ld</code></a></h2>
<p>Custom Linker script:</p>
<pre><code>MEMORY
{
  EXTRAM (rwx): ORIGIN = 0x60000000, LENGTH = 8*1024K
}

GROUP(libgcc.a libc.a libm.a)

SECTIONS
{
	.capi :
	{
		KEEP(*(.capi_handler))
		KEEP(*(.bss_start))
		KEEP(*(.bss_end))
	} &gt; EXTRAM

	.text :
	{
		*(.text)

		KEEP(*(.init))
		KEEP(*(.fini))

		/* .ctors */
		*crtbegin.o(.ctors)
		*crtbegin?.o(.ctors)
		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
		*(SORT(.ctors.*))
		*(.ctors)

		/* .dtors */
 		*crtbegin.o(.dtors)
 		*crtbegin?.o(.dtors)
 		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
 		*(SORT(.dtors.*))
 		*(.dtors)

		*(.rodata*)

		KEEP(*(.eh_frame*))

	} &gt; EXTRAM

	.data :
	{
		__etext = .;

		__data_start__ = .;
		*(vtable)
		*(.data*)

		. = ALIGN(4);
		/* preinit data */
		PROVIDE_HIDDEN (__preinit_array_start = .);
		KEEP(*(.preinit_array))
		PROVIDE_HIDDEN (__preinit_array_end = .);

		. = ALIGN(4);
		/* init data */
		PROVIDE_HIDDEN (__init_array_start = .);
		KEEP(*(SORT(.init_array.*)))
		KEEP(*(.init_array))
		PROVIDE_HIDDEN (__init_array_end = .);

		. = ALIGN(4);
		/* finit data */
		PROVIDE_HIDDEN (__fini_array_start = .);
		KEEP(*(SORT(.fini_array.*)))
		KEEP(*(.fini_array))
		PROVIDE_HIDDEN (__fini_array_end = .);

		. = ALIGN(4);
		/* All data end */
		__data_end__ = .;

	} &gt; EXTRAM

	.bss :
	{
		. = ALIGN(4);
		__bss_start__ = .;
		*(.bss*)
		*(COMMON)
		. = ALIGN(4);
		__bss_end__ = .;

	} &gt; EXTRAM

  /DISCARD/ :
  {
		*(.ARM.exidx)
  }

}
</code></pre>
<p>The important parts of this linker script are that its making a <code>rwx</code> (Read Write Execute)
section at addresss <code>0x60000000</code> and of size 8M. It then maps all the code onto it, and
all data as well. Starting at offset <code>0x0</code> the sections, in order will be:</p>
<ul>
<li><code>.capi</code></li>
<li><code>.text</code></li>
<li><code>.data</code></li>
<li><code>.bss</code></li>
</ul>
<h2 id="parsing-gamemap"><a class="header" href="#parsing-gamemap">Parsing <code>game.map</code></a></h2>
<p>Important output from <code>game.map</code>:</p>
<p>Eventually you get to the part of <code>game.map</code> that is going to detail all the sections,
symbols, addresses, sizes, and source compilation units. This is what is going to get
generated into the elf, and is <em>almost</em> what is run on the device.</p>
<pre><code>.capi           0x0000000060000000        0xc
 *(.capi_handler)
 .capi_handler  0x0000000060000000        0x4 CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj
                0x0000000060000000                PD_eventHandler
 *(.bss_start)
 .bss_start     0x0000000060000004        0x4 CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj
                0x0000000060000004                _bss_start
 *(.bss_end)
 .bss_end       0x0000000060000008        0x4 CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj
                0x0000000060000008                _bss_end

.text           0x000000006000000c      0x19c
 *(.text)
 .text          0x000000006000000c       0x88 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o
 .text          0x0000000060000094        0xc /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-atexit.o)
                0x0000000060000094                atexit
 .text          0x00000000600000a0       0x34 /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-fini.o)
                0x00000000600000a0                __libc_fini_array
 .text          0x00000000600000d4       0x4c /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-rand.o)
                0x00000000600000d4                srand
                0x00000000600000e4                rand
 .text          0x0000000060000120       0x68 /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-__atexit.o)
                0x0000000060000120                __register_exitproc
 *(.init)
 .init          0x0000000060000188        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crti.o
                0x0000000060000188                _init
 .init          0x000000006000018c        0x8 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtn.o
 *(.fini)
 .fini          0x0000000060000194        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crti.o
                0x0000000060000194                _fini
 .fini          0x0000000060000198        0x8 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtn.o
 *crtbegin.o(.ctors)
 *crtbegin?.o(.ctors)
 *(EXCLUDE_FILE(*crtend.o *crtend?.o) .ctors)
 *(SORT_BY_NAME(.ctors.*))
 *(.ctors)
 *crtbegin.o(.dtors)
 *crtbegin?.o(.dtors)
 *(EXCLUDE_FILE(*crtend.o *crtend?.o) .dtors)
 *(SORT_BY_NAME(.dtors.*))
 *(.dtors)
 *(.rodata*)
 .rodata        0x00000000600001a0        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-impure.o)
                0x00000000600001a0                _global_impure_ptr
 *(.eh_frame*)
 .eh_frame      0x00000000600001a4        0x0 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o
 .eh_frame      0x00000000600001a4        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtend.o

.glue_7         0x00000000600001a8        0x0
 .glue_7        0x00000000600001a8        0x0 linker stubs

.glue_7t        0x00000000600001a8        0x0
 .glue_7t       0x00000000600001a8        0x0 linker stubs

.vfp11_veneer   0x00000000600001a8        0x0
 .vfp11_veneer  0x00000000600001a8        0x0 linker stubs

.v4_bx          0x00000000600001a8        0x0
 .v4_bx         0x00000000600001a8        0x0 linker stubs

.iplt           0x00000000600001a8        0x0
 .iplt          0x00000000600001a8        0x0 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o

.text.eventHandlerShim
                0x00000000600001b0       0x3c
 .text.eventHandlerShim
                0x00000000600001b0       0x3c CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj
                0x00000000600001b0                eventHandlerShim

.text.ison      0x00000000600001f0       0x44
 .text.ison     0x00000000600001f0       0x44 CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.val       0x0000000060000240       0x48
 .text.val      0x0000000060000240       0x48 CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.rowsum    0x0000000060000290       0x98
 .text.rowsum   0x0000000060000290       0x98 CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.middlerowsum
                0x0000000060000330       0x74
 .text.middlerowsum
                0x0000000060000330       0x74 CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.doRow     0x00000000600003b0       0xb0
 .text.doRow    0x00000000600003b0       0xb0 CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.randomize
                0x0000000060000460       0x64
 .text.randomize
                0x0000000060000460       0x64 CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.update    0x00000000600004d0       0xdc
 .text.update   0x00000000600004d0       0xdc CMakeFiles/Life_DEVICE.dir/main.c.obj

.text.eventHandler
                0x00000000600005b0       0x54
 .text.eventHandler
                0x00000000600005b0       0x54 CMakeFiles/Life_DEVICE.dir/main.c.obj
                0x00000000600005b0                eventHandler

.text.startup   0x0000000060000604       0x14
 .text.startup  0x0000000060000604       0x14 /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-__call_atexit.o)

.rel.dyn        0x0000000060000618        0x0
 .rel.iplt      0x0000000060000618        0x0 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o

.data           0x0000000060000618      0x43c
                0x0000000060000618                __etext = .
                0x0000000060000618                __data_start__ = .
 *(vtable)
 *(.data*)
 .data          0x0000000060000618      0x430 /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-impure.o)
                0x0000000060000618                _impure_ptr
                0x0000000060000a48                . = ALIGN (0x4)
                0x0000000060000a48                PROVIDE (__preinit_array_start = .)
 *(.preinit_array)
                0x0000000060000a48                PROVIDE (__preinit_array_end = .)
                0x0000000060000a48                . = ALIGN (0x4)
                0x0000000060000a48                PROVIDE (__init_array_start = .)
 *(SORT_BY_NAME(.init_array.*))
 .init_array.00000
                0x0000000060000a48        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/../../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc.a(lib_a-__call_atexit.o)
 *(.init_array)
 .init_array    0x0000000060000a4c        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o
                0x0000000060000a50                PROVIDE (__init_array_end = .)
                0x0000000060000a50                . = ALIGN (0x4)
                0x0000000060000a50                PROVIDE (__fini_array_start = .)
 *(SORT_BY_NAME(.fini_array.*))
 *(.fini_array)
 .fini_array    0x0000000060000a50        0x4 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o
                0x0000000060000a54                PROVIDE (__fini_array_end = .)
                0x0000000060000a54                . = ALIGN (0x4)
                0x0000000060000a54                __data_end__ = .

.tm_clone_table
                0x0000000060000a54        0x0
 .tm_clone_table
                0x0000000060000a54        0x0 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o
 .tm_clone_table
                0x0000000060000a54        0x0 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtend.o

.igot.plt       0x0000000060000a54        0x0
 .igot.plt      0x0000000060000a54        0x0 /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o

.bss            0x0000000060000a54       0x24
                0x0000000060000a54                . = ALIGN (0x4)
                0x0000000060000a54                __bss_start__ = .
 *(.bss*)
 .bss           0x0000000060000a54       0x1c /usr/lib/gcc/arm-none-eabi/8.3.1/thumb/v7e-m+fp/hard/crtbegin.o
 .bss.pdrealloc
                0x0000000060000a70        0x4 CMakeFiles/Life_DEVICE.dir/home/lockbox/d/o/play.date/sdk-1.12.3/C_API/buildsupport/setup.c.obj
 .bss.pd        0x0000000060000a74        0x4 CMakeFiles/Life_DEVICE.dir/main.c.obj
 *(COMMON)
                0x0000000060000a78                . = ALIGN (0x4)
                0x0000000060000a78                __bss_end__ = .

</code></pre>
<h3 id="tying-back-to-the-build-steps"><a class="header" href="#tying-back-to-the-build-steps">Tying back to the build steps</a></h3>
<p>A lot of the contents in the generated map are due to the <code>gcc</code> build options that were passed in.</p>
<ul>
<li><code>-ffunction-sections</code>
<ul>
<li>section symbols with names like <code>.text.evenHandlerShim</code> appear because this
switch gives each function it's own section</li>
<li>notice how symbols like <code>atexit</code> and <code>__libc_fini_array</code> etc. (functions from NOT
the play.date build system) only belong to the section <code>.text</code>? They don't have this
build switch enabled.</li>
</ul>
</li>
<li><code>-fdata-sections</code>
<ul>
<li>section symbols with names like <code>.bss.pdrealloc</code> and <code>.bss.pd</code> occur because of
this switch (see above). </li>
</ul>
</li>
</ul>
<p>Take note of the <code>.capi</code> section, and how there are ONLY three members (there will always
only be three due to <code>link_map.ld</code> above). This is the magic that creates a simple API
for all games to run hosted in their runtime.</p>
<h1 id="packing-step"><a class="header" href="#packing-step">Packing Step</a></h1>
<p>The packaging step is pretty simple, and uses a bunch of information from the link step.</p>
<pre><code class="language-bash"># copy the section contents from `Life_DEVICE.elf` into a binary blob
/usr/bin/arm-none-eabi-objcopy \
    -Obinary \
    Life_DEVICE.elf \
    /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life/Source/pdex.bin

# Package the binary blob in a .pdx archive
cd /home/lockbox/d/o/play.date/sdk-1.12.3/C_API/Examples/Life &amp;&amp; \
/home/lockbox/d/o/play.date/sdk-1.12.3/bin/pdc \
    -sdkpath /home/lockbox/d/o/play.date/sdk-1.12.3 \
    Source \
    Life.pdx
</code></pre>
<p>All <code>objcopy</code> is going to do in this step is take the section contents from the elf and
dump them into a blob, this is effectively doing a memory map dump to disk. And because
in the link step it mashed all the sections next to each other there is one contiguous
blob of all our code + literal pools + data etc. No relocations necessary :D</p>
<p>In effect we get the information from <code>game.map</code> actualized into a <code>.bin</code>. The contents of
our <code>.bin</code> file are repsented exactly as defined in <code>game.map</code>, the only difference being
thatthe beginning of the <code>.bin</code> is (duh) going to be offset <code>0x0</code>, but will be relocated to
<code>0x60000000</code> on the actual device.</p>
<p>The <code>pdc</code> invocation when using C only projects basically just packages the bytes into the game archive far as I can tell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-structure"><a class="header" href="#binary-structure">Binary Structure</a></h1>
<p>TLDR; the compiled binary looks like this (Note that address <code>0x0</code> is actually <code>0x60000000</code> when run on hardware):</p>
<p><img src="binary/./layout.png" alt="layout.svg" /></p>
<p>What this means is that:</p>
<ul>
<li>the first word in the binary ust be a pointer to our &quot;event handler&quot;</li>
<li>the second word points to the start of our program globals</li>
<li>the third word points to the end of program globals</li>
</ul>
<p>Offhand I'm not sure the purpose of the runtime knowing the beginning + end of
the program global data, unless they're extending the heap to use that space
or something.</p>
<p>What we also learned from the <a href="binary/./game.map">game.map</a> is that we're going
to be shoving a ton of extra runtime stuff for the hard float random stuff
into the binary we're producing (<code>Life</code> uses <code>rand()</code>). The source for all that
included code can be found in the <code>gcc</code> source tree.</p>
<h2 id="game-binary"><a class="header" href="#game-binary">Game Binary</a></h2>
<p>When the game is mapped into memory the runtime then calls the game's provided
event handler with the init event. So execution flow looks something like:</p>
<pre><code>- loadGame()
- initGame()
    - game.eventHandler(&amp;self, kEventInit, 0)
        - eventHandlerShim(pd, evt, arg)
            - eventHandler(pd, evt, arg)
</code></pre>
<p>from <code>setup.c</code> we know that <code>eventHandlerShim()</code> is just:</p>
<pre><code class="language-c">int eventHandlerShim(PlaydateAPI* playdate, PDSystemEvent event, uint32_t arg)
{
	if ( event == kEventInit )
		pdrealloc = playdate-&gt;system-&gt;realloc;
	
	return eventHandler(playdate, event, arg);
}
</code></pre>
<p>Whih is a little disappointing that they add the extra function call overhead as its only going to be used once per game session. So this is an interesting overhead addition after they (Panic Inc.) have already shown that they are both:</p>
<ul>
<li>willing to add extra sections to emitted game binary</li>
<li>willing to arrange sections and add extra pointers to game binary</li>
</ul>
<p>Some alternatives that could reduce this (small, but passive and unavoidable) runtime overhead (ignoring the rest of the time spent in the play.date OS interrupts + runtime etc.) could be things like:</p>
<ul>
<li>add a pointer to <code>.bss.pdrealloc</code> in <code>.capi</code>, so the runtime can overwite it itself</li>
<li>move the realloc function during the link step to change it's section, then overwrite it (though the previous idea would be considerably easier)</li>
</ul>
<p>Either way, the game program is a self contained image that is not PIC (poisiton independant code), but based at <code>0x60000000</code>, and is provided a pointer to
the playdate api each &quot;interrupt.&quot;</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-console"><a class="header" href="#game-console">Game Console</a></h1>
<p>We know that new games get delivered over Wi-Fi, and that
there is an ESP8266 <a href="https://fccid.io/2AR29-PDU01/Internal-Photos/Internal-Photos-4801627.pdf">onboard (pg. 2)</a>, but there is also no interface to communicate
with it via the play.date SDK, so we'll have to do a little digging and try to
look at the underlying operating system.</p>
<p>To do that we're going to need to write some code to figure out where the
OS is stored, where the heap is, where code objects are, which flash banks are being used, whch hardware is being used etc.</p>
<p>We do know that the <a href="https://github.com/jaames/playdate-reverse-engineering/blob/main/usb/usb.md#esp">ESP8266 is connected via UART</a>, and we also know that
there is a <a href="https://sdk.play.date/1.12.3/Inside%20Playdate%20with%20C.html#_accelerometer">peripheral accelerometer</a>
onboard as well (and soon a <a href="https://play.date/stereo-dock/">stereo dock</a>, though
they redid the FCC filing for it in <a href="https://fccid.io/2AR29-PDDY01">December 2022</a> so we probably have to wait a bit).</p>
<ul>
<li><a href="console/./ValidMemory.html">Valid Memory</a></li>
<li><a href="console/./peripherals.html">Connected Peripherals</a></li>
<li><a href="console/">Game Console overview</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-valid-memory"><a class="header" href="#finding-valid-memory">Finding Valid Memory</a></h1>
<p>To determine valid memory address ranges in RAM, we can start with a couple of easy no-crash-no-risk methods before just yolo touching different regions to see
if the play.date crashes or not</p>
<p>First we're going to try</p>
<ul>
<li>Using the <code>PlaydateAPI</code> address to get valid regions</li>
<li>Using allocator memory to get a valid region</li>
<li>Get the stack memory</li>
<li>Look at function addresses to see where valid code space is</li>
<li>Walk the stack</li>
</ul>
<h2 id="using-the-playdateapi-address"><a class="header" href="#using-the-playdateapi-address">Using the PlaydateAPI address</a></h2>
<p>Using the pointer provided to our event handler we can mask off the lower bits
and find which RAM bank the heap with the playdate object is in (or stack address / flash address
if its not stored on the heap, TBD)</p>
<p>Using some quick n dirty C we can dump the address to the screen like below:</p>
<p><img src="console/./api_address.gif" alt="api_address.gif" /></p>
<p>C snippet:</p>
<pre><code class="language-c">static void log_addresses(PlaydateAPI *pd)
{
    char * api_base;
    char * pd_address;

    // create the statements
    pd-&gt;system-&gt;formatString(&amp;api_base, &quot;API Base Address: %p&quot;, (uint32_t)pd &amp; 0xf0000000);
    pd-&gt;system-&gt;formatString(&amp;pd_address, &quot;PD API Address: %p&quot;, pd);    

    // write the statements
    write_line(pd, api_base);
    write_line(pd, pd_address);

    // free the statements
    FREE(api_base);
    FREE(pd_address);
}
</code></pre>
<p>What this tells us is that the pd api is allocated in SRAM (system SRAM
starts at <code>0x20000000</code> as per <a href="https://www.st.com/resource/en/reference_manual/dm00124865-stm32f75xxx-and-stm32f74xxx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf">docs section 2.3</a>).
Cool, now that we have some progress, we're going to dump some more
addresses to see what we're working with.</p>
<h2 id="using-more-addresses"><a class="header" href="#using-more-addresses">Using more addresses</a></h2>
<p>Now we're going to still use the pd api address, but now we're going to
allocate something on the heap and use that address as well, and allocate
something on the stack and use that address (Note that the stack is setup
to be only <code>61800</code> bytes a la <code>C_API/buildsupport/*.cmake</code> and
<code>C_API/Examples/*/Makefile</code>).</p>
<p>So, lets see what we got:</p>
<p><img src="console/./addresses.png" alt="addresses" /></p>
<p>corresponding snippet:</p>
<pre><code class="language-c">static void log_addresses(PlaydateAPI *pd)
{
    char * api_base;
    char * pd_address;
    char * heap_obj;
    char * heap_base;
    char * stack_obj;
    char * stack_base;
    char * code_ptr;

    // create the statements
    pd-&gt;system-&gt;formatString(&amp;api_base, &quot;API Base Address: %p&quot;, (uint32_t)pd &amp; 0xf0000000);
    pd-&gt;system-&gt;formatString(&amp;pd_address, &quot;PD API Address: %p&quot;, pd);
    pd-&gt;system-&gt;formatString(&amp;heap_base, &quot;Heap Base Address: %p&quot;, ((uint32_t)api_base &amp; 0xf0000000));
    pd-&gt;system-&gt;formatString(&amp;heap_obj, &quot;Heap Address: %p&quot;, api_base);
    pd-&gt;system-&gt;formatString(&amp;stack_base, &quot;Stack Base Address: %p&quot;, ((uint32_t)&amp;api_base &amp; 0xf0000000));
    pd-&gt;system-&gt;formatString(&amp;stack_obj, &quot;Stack Address: %p&quot;, &amp;api_base);
    pd-&gt;system-&gt;formatString(&amp;code_ptr, &quot;&amp;formatString: %p&quot;, pd-&gt;system-&gt;formatString);

    // write the statements
    write_line(pd, api_base);
    write_line(pd, pd_address);
    write_line(pd, heap_base);
    write_line(pd, heap_obj);
    write_line(pd, stack_base);
    write_line(pd, stack_obj);
    write_line(pd, code_ptr);

    // free the statements
    FREE(api_base);
    FREE(pd_address);
    FREE(heap_base);
    FREE(heap_obj);
    FREE(stack_base);
    FREE(stack_obj);
    FREE(code_ptr);
}
</code></pre>
<p>Cool, so this looks like we have a (so far) deterministic stack address
(<code>0x2003807c</code>) for the pd api handle, and that the heap objects we
allocate during games are going to be allocated immediately after the
game code (remember that the game is mapped to <code>0x60000000</code>) in ram.
Additionally this shows us that the flash region beng used for code
(specifically the flash region that <code>pd-&gt;system-&gt;formatString</code> is in)
is the flash bank that starts at <code>0x8000000</code>.</p>
<p>Flash bank table for reference (<a href="https://www.st.com/resource/en/reference_manual/dm00124865-stm32f75xxx-and-stm32f74xxx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf">section 3.3.1</a>):</p>
<p><img src="console/./flash_blocks.png" alt="flash_blocks.png" /></p>
<p>So what we can glean from this table (and the fact that we can run code on it)
is that we have permission to access the memory and execute it (haven't seen
many things that allow execute only permissions), and that the entire flash
region is from address <code>0x08000000</code> to <code>0x080FFFFF</code>). So we can probably just
dump all that code right now if we wanted to, BUT we still have a fun exercise
comming up.</p>
<h2 id="walking-the-stack"><a class="header" href="#walking-the-stack">Walking the stack</a></h2>
<p>This is a fun exercise of walking the stack, intuitively we will imagine
the stack growing down, as the addresses decrease the more items you add.
Note that because we are executing exclusively in <code>Thumb2</code> mode
the calling convention / ABI that will be used on the play.date is
documented <a href="https://developer.arm.com/documentation/dui0041/c/Thumb-Procedure-Call-Standard/About-the-Thumb-Procedure-Call-Standard">here</a>.</p>
<p>You should probably skim this real quick before continuing.</p>
<p>Note this fun highlight from the docs:</p>
<blockquote>
<p><code>fp</code> is usually not used in Thumb state</p>
</blockquote>
<p>And note the register names they use:</p>
<table><thead><tr><th>Register</th><th>TPCS name</th><th>TPCS role</th></tr></thead><tbody>
<tr><td>r0</td><td>a1</td><td>argument 1/scratch register/result</td></tr>
<tr><td>r1</td><td>a2</td><td>argument 2/scratch register/result</td></tr>
<tr><td>r2</td><td>a3</td><td>argument 3/scratch register/result</td></tr>
<tr><td>r3</td><td>a4</td><td>argument 4/scratch register/result</td></tr>
<tr><td>r4</td><td>v1</td><td>register variable</td></tr>
<tr><td>r5</td><td>v2</td><td>register variable</td></tr>
<tr><td>r6</td><td>v3</td><td>register variable</td></tr>
<tr><td>r7</td><td>v4/wr</td><td>register variable/work register in function entry/exit</td></tr>
<tr><td>r8</td><td>(v5)</td><td>(ARM v5 register, no defined role in Thumb)</td></tr>
<tr><td>r9</td><td>(v6)</td><td>(ARM v6 register, no defined role in Thumb)</td></tr>
<tr><td>r10</td><td>sl (v7)</td><td>stack limit</td></tr>
<tr><td>r11</td><td>fp (v8)</td><td>frame pointer (usually not used in Thumb state)</td></tr>
<tr><td>r12</td><td>(ip)</td><td>(ARM ip register, no defined role in Thumb. May be used as a temporary register on Thumb function entry/exit.)</td></tr>
<tr><td>r13</td><td>sp</td><td>stack pointer (full descending stack)</td></tr>
<tr><td>r14</td><td>lr</td><td>link register</td></tr>
<tr><td>r15</td><td>pc</td><td>program counter</td></tr>
</tbody></table>
<p>They double down on the no-frame-pointer-use when discussing <a href="https://developer.arm.com/documentation/dui0041/c/Thumb-Procedure-Call-Standard/TPCS-definition/Control-arrival">control arrival</a>:</p>
<pre><code>At the instant when control arrives at the target function:

    - pc contains the address of an entry point to the target function.

    - lr contains the value to restore to pc on exit from the function
    (the return link value, see The stack backtrace data structure).

    - sp points at or above the current stack limit. If the limit is
    explicit, sp will point at least 256 bytes above it (see The 
    Stack).

    - If the function is built to use a frame pointer register, fp 
    contains 0 or points to the most recently created stack backtrace 
    structure (see The stack backtrace data structure). This is not 
    usual in Thumb state.

    - The space between sp and the stack limit must be readable and 
    writable memory which the called function can use as temporary 
    workspace, and overwrite with any values before the function 
    returns (see The Stack).
</code></pre>
<p>Note that argument passing is more or less standard for a computer
architecture, (well at least nothing is too out of the ordinary as
specified in the <a href="https://developer.arm.com/documentation/dui0041/c/Thumb-Procedure-Call-Standard/TPCS-definition/Data-representation-and-argument-passing">argument passing</a> document, though there
are many real-world cases where that is not honored, not too worried about that here though).</p>
<pre><code>At the instant control arrives at the target function, the argument 
list is allocated as follows:

    - the first four argument words (or fewer if there are fewer than 
    four argument words remaining in the argument list) are in machine 
    registers a1-a4

    - the remainder of the argument list (if any) is in memory, at the 
    location addressed by sp and higher addressed words thereafter.

    - A floating-point value is treated as one, two, or three integer 
    values, as appropriate to its precision. The TPCS does not support 
    the passing or returning of floating-point values in ARM 
    floating-point registers.
</code></pre>
<p>And last but not least, <a href="https://developer.arm.com/documentation/dui0041/c/Thumb-Procedure-Call-Standard/TPCS-definition/Control-return">control return</a></p>
<pre><code>When the return link value for a function call is placed in the pc:

    - sp, fp, sl, v6, v5, and v1-v4 contain the same values as they 
    did at the instant of control arrival. If the function returns a 
    simple value of size one word or less, the value is contained in 
    a1.

    - If the function returns a simple value of size one word or less, 
    then the value must be in a1. A language implementation is not 
    obliged to consider all single-word values simple. See Non-simple 
    value return.

    - If the function returns a simple floating-point value, the value 
    is encoded in a1, {a1, a2}, or {a1, a2, a3}, depending on its 
    precision.
</code></pre>
<p>SO, time to cry. basically because by default thumb mode omit's the frame
pointer theres not going to be frame's to jump back to. Instead of doing
some fun tricks and heuristics to figure out what our frames are, we're just
going to dump flash. Because I don't want to think that hard.</p>
<p>But we know that we can read the flash section, and we know that the
onboard <code>SRAM</code> is used for the stack, and that the <code>0x60000000</code> region that
our code gets mapped to is where our heap is.</p>
<p>Next: <a href="console/../pdOS/DumpingFlash.html">Dumping Flash</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connected-peripherals"><a class="header" href="#connected-peripherals">Connected peripherals</a></h1>
<h2 id="esp-chip"><a class="header" href="#esp-chip">ESP chip</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pd-os"><a class="header" href="#pd-os">pd-OS</a></h1>
<p>As I've been going through this exercise of looking at the play.date console
I've been hoping there's some cool name for the underlying operating system.
Their Playdate account management and game distribution system is called
<a href="https://panic.com/blog/help-wanted-python-web-services-engineer-early-2022/">WOPR</a>,
and they made the legendary <a href="https://goose.game/">Untitled Goose Game</a>.
Unfortunately the OS is just called <a href="https://panic.com/blog/help-wanted-playdate-senior-qa-release-engineer-march-2022/">Playdate OS</a>.</p>
<p>Anyways, lets take a look at it.</p>
<ul>
<li><a href="pdOS/./DumpingFlash.html">Dumping Flash</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dumping-flash"><a class="header" href="#dumping-flash">Dumping Flash</a></h1>
<p>From <a href="pdOS/../console/ValidMemory.html"><code>Valid Memory</code></a> we know that flash starts
at <code>0x08000000</code> and goes until <code>0x080FFFFF</code>. So lets write up a quick C stub
to dump it over serial, and a python script to pickup the dump.</p>
<p>See pd-usb for details but the high level is that you just need to connect
with baud rate <code>115200</code> to the play.date, the ID's (just in case you want custom
udev rules for mitm serial or something similar, or its not under <code>/dev/ttyACM0</code>) are:</p>
<ul>
<li>Vendor ID: <code>0x1331</code></li>
<li>Product ID: <code>0x5740</code></li>
</ul>
<p>The general algorithm is very simple:</p>
<blockquote>
<p>Note:</p>
<p>Flash has a default value of <code>0xffffffff</code>, so I used shortcut logic to
wait until 100 were read in a row, no need to waste time, though the baud
rate is 115200 so at least it moves pretty quick in this case. Many times
you need to do this it is prohibitively slow to read + dump flash though.</p>
</blockquote>
<pre><code class="language-c">static void dump_flash(PlaydateAPI *pd)
{
    uint32_t addr;
    uint32_t value = 0;
    uint32_t default_value = 0; // number of consecutive ``0xffffffff``

    // pattern so python script to pickup the dump knows we're printing
    println(&quot;0x%08x, 0x%08x, dump_start:\r\n&quot;, FLASH_START, FLASH_END);

    // iterate over each word in flash, and dump it
    for (addr = FLASH_START; addr &lt;= FLASH_END; addr += 0x4)
    {
        value = *((uint32_t *)addr);

        // check if ``0xffffffff``
        if (value == 0xffffffff)
        {
            default_value++;
            
            // if there are 100 ``0xffffffff`` in a row then quit,
            // assume that we hit the end of the flash memory used
            if (default_value &gt;= 100)
                break;
        }
        else
        {
            default_value = 0;
        }

        println(&quot;0x%08x: 0x%08x\r\n&quot;, addr, value);
    }
}
</code></pre>
<h3 id="a-couple-speed-bumps-along-the-way"><a class="header" href="#a-couple-speed-bumps-along-the-way">A couple speed bumps along the way:</a></h3>
<blockquote>
<p>So I've been using the docs as given in the <a href="pdOS/">awesome playdate</a> repo,
which started crashing things a bunch when reading from flash <code>0x08000000</code>
until <code>0x08050000</code> which then let me dump until the end of flash, so I
went back through the FCC filing photos to see the actual MCU onboard.</p>
<p>The actual MCU is <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32f746ie.html">STM23f746ie</a>, which really doesn't change
anything wrt what docs to use. So for the moment I'm still stumped why it's
crashing attempting to read flash below <code>0x08050000</code>.</p>
<p>Then I found <a href="https://github.com/STMicroelectronics/STM32CubeF7/blob/master/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_flash_ex.c#L914">this</a>,</p>
</blockquote>
<p>Step 1: get the typedef for the System Flash Registers:</p>
<pre><code class="language-c">// github STM32CubeF7/Drivers/CMSIS/Device/ST/STM32F7xx/Include/stm32f7xx.h
typedef struct
{
  __IO uint32_t ACR;      /*!&lt; FLASH access control register,     Address offset: 0x00 */
  __IO uint32_t KEYR;     /*!&lt; FLASH key register,                Address offset: 0x04 */
  __IO uint32_t OPTKEYR;  /*!&lt; FLASH option key register,         Address offset: 0x08 */
  __IO uint32_t SR;       /*!&lt; FLASH status register,             Address offset: 0x0C */
  __IO uint32_t CR;       /*!&lt; FLASH control register,            Address offset: 0x10 */
  __IO uint32_t OPTCR;    /*!&lt; FLASH option control register ,    Address offset: 0x14 */
  __IO uint32_t OPTCR1;   /*!&lt; FLASH option control register 1 ,  Address offset: 0x18 */
} FLASH_TypeDef;
</code></pre>
<p>Well so we're still crashing, heck. So they probably are using the Memory Protection Unit.
At least we could dump user flash. Time to try to dump some more stuff and move on.</p>
<p>See if we can dump OTP memory, though it might also be protected.
It starts at <code>0x1FF0F000</code> and is (16 * 64) bytes (16 banks):</p>
<pre><code class="language-c">#define OTP_START 0x1FF0F000UL
#define OTP_END OTP_START + (16 * 64)

static void dump_otp(PlaydateAPI *pd)
{
    uint32_t addr;
    uint32_t value = 0;

    println(&quot;0x%08x, 0x%08x, dump_start:\r\n&quot;, OTP_START, OTP_END);

    for (addr = OTP_START; addr &lt;= OTP_END; addr += 0x4)
    {
        value = *((uint32_t *)addr);

        // print value
        println(&quot;%08x\r\n&quot;, value);
    }
}
</code></pre>
<p>F.</p>
<p>Still crashing, tho duh we're still not privileged.</p>
<p>Time to go about this a different way - what if their kernel doesn't do usermode pointer validation?</p>
<p>Lets try again:</p>
<pre><code class="language-c">static void write_kmem_to_file(PlaydateAPI *pd, uint32_t base, uint32_t size, const char *fname)
{
    SDFile *file = pd-&gt;file-&gt;open(fname, kFileWrite);

    // make sure we can actually write to a file
    if (file == NULL)
    {
        WRITE_FSTRING(pd, &quot;%s was unable to be opened because:\n\t%s&quot;, fname, pd-&gt;file-&gt;geterr());
        return;   
    }

    // tell the kernel to write to the file
    if ((-1 == pd-&gt;file-&gt;write(file, (void*)base, size)) == 1)
    {
        WRITE_FSTRING(pd, &quot;ERROR when writing to file:\n\t%s&quot;, pd-&gt;file-&gt;geterr());
        return;
    }

    // close the file
    pd-&gt;file-&gt;close(file);
}


static void dump_otp(PlaydateAPI *pd)
{
    WRITE_FSTRING(pd, &quot;Attempting to read memory from %p to %p&quot;, OTP_START, OTP_END);
    write_kmem_to_file(pd, OTP_START, OTP_END - OTP_START, &quot;otp_mem.bin&quot;);
}
</code></pre>
<p>Still crashing, though after looking back through the re notes I noticed</p>
<ol>
<li>they do use OTP (cool) and</li>
<li>once upon a time they <a href="https://github.com/jaames/playdate-reverse-engineering/blob/main/usb/usb.md#unlock">didn't validate the pointers</a> (or something to that effect - most likely they MPU wasn't actually enabled).</li>
</ol>
<p>Upon further attempts I'm assuming that any memory accessed by the kernel for
the process is limited to the program stack / heap as the following did not work.</p>
<ul>
<li>start of flash <code>0x08000000</code></li>
<li>known kernel addresses (from forcing crashes) <code>0x0803xxxx</code></li>
<li>known user space addresses (from pd api) <code>0x0805xxxx</code></li>
<li>system registers</li>
<li>OTP memory</li>
</ul>
<p>So after perusing the forums a <a href="https://devforum.play.date/t/file-open-crashes-on-device-c-api/9841/11">bit</a> it's using (as i actually assumed
right for once) <a href="https://www.freertos.org/">FreeeRTOS</a>. And now it looks like
the new play.date versions are using (working) MPU builds, rude.</p>
<p>Oh well, got user mode dumps, time to RE a bit.</p>
<p>Next: <a href="pdOS/./TriagingUserFlashDump.html">Triaging User Flash Dump</a></p>
<p><img src="https://media.tenor.com/jdFD8PpUK64AAAAC/skeletor-running-away.gif" alt="skeletor.gif" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triaging-user-mode-dump"><a class="header" href="#triaging-user-mode-dump">Triaging User Mode Dump</a></h1>
<p>Before pigeon-holing too hard on something in particular it's good to go over
the goals of what you're doing and what a decent path forward might actually be.
This is especially important for things like reversing an entire OS / bare metal
system where you have interrupts firing all over the place, a ton of third party
code, vendor SDK code, and the actual target code you care about.</p>
<p>SO, in the spirit of &quot;seeing where we're at&quot;, we can take a step back and go over
the goals again:</p>
<ol>
<li>Figure out how to talk to Wi-Fi</li>
<li>Figure out the limits of being &quot;unprivileged&quot;</li>
<li>Kernel mode dump (disclaimer, its not hard - but most likely unnecessary for Wi-Fi)</li>
<li>Reverse all the things</li>
</ol>
<p>So focusing on task 1, there are a few sub tasks that will probably lead to most of the
others getting done in the process.</p>
<ul>
<li>Label all the public SDK functions</li>
<li>Label FreeRTOS functions</li>
<li>If there are any in user space, find the memfault functions</li>
<li>Find each of the running threads</li>
<li>Find the thread that talks to the ESP wifi chip on board</li>
<li>Figure out which IPC method they use to control that thread</li>
</ul>
<p>The high level workflow for the intial triage of user space is going to roughly follow:</p>
<ul>
<li>look @ <code>PlaydateSimulator.debug</code> for type information we can <em>maybe</em> use (
or at least get a reference for their programming paradigms)</li>
<li>make a playdate game to dump addresses for all of the documented API's
<ul>
<li>im assuming that some scoreboard api has some Wi-Fi things under the hood
will probably get us close</li>
</ul>
</li>
<li>look at <code>FreeRTOS</code> source to figure out what some of the syscalls are, then work
up to the pd api functions</li>
<li>if there's 0 progress:
<ul>
<li>we can reverse some of the season games to figure out what's going on
(but that's cheating :p )</li>
<li>look for hardcoded <a href="https://docs.espressif.com/projects/esp-at/en/latest/esp32/AT_Command_Set/Basic_AT_Commands.html">AT commands</a>, tried and true &quot;grep flag&quot; basically always works,
but is suuuper anti-climactic</li>
</ul>
</li>
</ul>
<p>So without further ado, let's jump in</p>
<h1 id="babys-first-binary-dump"><a class="header" href="#babys-first-binary-dump">Baby's first binary dump</a></h1>
<p>We'll use <a href="https://binary.ninja">binary.ninja</a> to reverse the code on the playdate,
note that we're in thumb2 mode and our starting offset is not 0. So when we first
open the binary dump we should see this:</p>
<p><img src="pdOS/./binary_ninja_first_open.png" alt="first_open.png" /></p>
<p>Make sure to change the image base address to <code>0x08050000</code>.</p>
<p>Also switch it to disassembly so things look clearer - binary ninja is not best suited
for non standard targets, and all disassemblers are notoriously bad at arm / thumb / vfp,
so we'll take it easy on it. Notice how all of the functions aren't named, and things
are all over the place (duh its a binary dump). We have some work to do.</p>
<h2 id="step-1---applying-debug-types"><a class="header" href="#step-1---applying-debug-types">Step 1 - Applying debug types</a></h2>
<p>The first step is going to be installing the dwarf debug info plugin that
vector35 published, then <em>ugh</em> restarting binary ninja. But afterwards we can now import
debug info from the shipped external <code>PlaydateSimulator.debug</code> file from the SDK.</p>
<p><img src="pdOS/./dwarf_debug_plugin.png" alt="./import_debug_info" /></p>
<p>And now all the types are applied we can export the types to a header file.</p>
<p>Turning the provided <code>dwarf2</code> debug file into a header we get <a href="pdOS/">this</a>. We can
import the header into binary ninja with some extra flags [as documented below],
and then we will have those as needed hen we find stuff. Note that we probably
won't use those types much in user space but better safe than sorry. Also now
that binary ninja literally <a href="https://binary.ninja/2023/01/18/3.3-the-bytes-must-flow.html#import--export-header-files">just stabilized</a>
the header / type importing I figured I'd go ahead and give it a whirl.</p>
<h2 id="step-15---importing-the-sdk-c-types"><a class="header" href="#step-15---importing-the-sdk-c-types">Step 1.5 - Importing the SDK C Types</a></h2>
<p>The more useful thing to import into binary ninja for looking at user space is
going to be the <code>C_API</code> (specifically the <code>pd_api.h</code> header). Note that
binary ninja uses <a href="https://binary.ninja/2022/10/28/3.2-released.html#default-to-clang-type-parser">clang type parser</a>
for their header importing, so now we can import the headers with the arguments
from the compiler like so:</p>
<p>Import selection is here:</p>
<p><img src="pdOS/./import_headers_select.png" alt="./import_headers_select.png" /></p>
<p>Then add the compiler options:</p>
<p><img src="pdOS/./import_headers_1.png" alt="./import_headers_1.png" /></p>
<p>And it worked (this time), though it failed the first time I tried to, and reading the
<a href="https://docs.binary.ninja/guide/type.html#import-header-file">documentation</a> shows that
there are extra arguents necessary to add the system types, so you might need to add those.
On my machine it looked like:</p>
<p><img src="pdOS/./import_headers_2.png" alt="./import_headers_2.png" /></p>
<p>Now we can directly use the types directly (instead of hand-jamming them) for the next step:</p>
<h2 id="step-2---dumping-the-api-addresses"><a class="header" href="#step-2---dumping-the-api-addresses">Step 2 - Dumping the API addresses</a></h2>
<p>The Playdate API is super nice and user friendly, and is half the reason I started
writing all this stuff up. So now that we've imported all the Playdate <code>C_API</code>
types and functions we need to dump the addresses from a real device so we can
properly label them in the memory dump we're reversing in binary ninja.</p>
<p>So to do this we're going to dump all of the tables in the main <code>PlaydateAPI</code>
struct (each of the struct members is a pointer to anotherb struct of
function pointers), and afterwards we will use that to label the corresponding
functions in binary ninja.</p>
<p>Corresponding code snippet:</p>
<pre><code class="language-C">/**
 * \brief macro to dump pointer tables, looks super fancy but all its really doing
 * is:
 *   - starting a json object for the table with the provided name, address, and size.
 *   - dumping each word as 4 zero padded bytes in a hex string as a part of the data
 *     array in the json object
 */
#define LOG_TABLE(__pd, __name, __sz, __ptr)                                                \
    do                                                                                      \
    {                                                                                       \
        WRITE_FCONSOLE(__pd,                                                                \
                       &quot;{\&quot;name\&quot;: \&quot;%s\&quot;, \&quot;address\&quot;: \&quot;%p\&quot;, \&quot;size\&quot;: %d, \&quot;data\&quot;: [&quot;, \
                       __name,                                                              \
                       (void *)__ptr,                                                       \
                       __sz);                                                               \
        for (int i = 0; i &lt; __sz / 4; i++)                                                  \
        {                                                                                   \
            WRITE_FCONSOLE(__pd, &quot;\&quot;%08x\&quot;,&quot;, *(((uint32_t *)__ptr) + i));                  \
        }                                                                                   \
        WRITE_FCONSOLE(__pd, &quot;%s&quot;, &quot;]}&quot;);                                                   \
    } while (0)

/**
 * \brief dumps a jsonl of symbols to the console
 */
static void log_addresses(PlaydateAPI *pd)
{
    LOG_TABLE(pd, &quot;pd-&gt;system&quot;, sizeof(struct playdate_sys), pd-&gt;system);
    LOG_TABLE(pd, &quot;pd-&gt;file&quot;, sizeof(struct playdate_file), pd-&gt;file);
    LOG_TABLE(pd, &quot;pd-&gt;graphics&quot;, sizeof(struct playdate_graphics), pd-&gt;graphics);
    LOG_TABLE(pd, &quot;pd-&gt;sprite&quot;, sizeof(struct playdate_sprite), pd-&gt;sprite);
    LOG_TABLE(pd, &quot;pd-&gt;display&quot;, sizeof(struct playdate_display), pd-&gt;display);
    LOG_TABLE(pd, &quot;pd-&gt;sound&quot;, sizeof(struct playdate_sound), pd-&gt;sound);
    LOG_TABLE(pd, &quot;pd-&gt;lua&quot;, sizeof(struct playdate_lua), pd-&gt;lua);
    LOG_TABLE(pd, &quot;pd-&gt;json&quot;, sizeof(struct playdate_json), pd-&gt;json);
    LOG_TABLE(pd, &quot;pd-&gt;scoreboards&quot;, sizeof(struct playdate_scoreboards), pd-&gt;scoreboards);
    WRITE_FSTRING(pd, &quot;Wrote tables to console&quot;, &quot;&quot;);
}
</code></pre>
<p>This will output json for each pointer table, and give us most of the information
we need without doing toooo much work in C. (initially I started dumping the name
of each function as well but that started to be too much in C).</p>
<p>Also I started to get lazy, so we'll just look at the playdate simulator console
and look at the output to line it up with the api headers and binary ninja.</p>
<p>Each function table is going to get dumped in order, so we can just walk down the
list of functions in each struct and directly apply things in binry ninja.</p>
<p>Snapshot:</p>
<p><img src="pdOS/./dumping_api_addresses.png" alt="./dumping_api_addresses.png" /></p>
<p>Cool, we can go back to binary ninja and apply the <code>playdate_sys</code> struct type
to the address listed, and hopefully that will just label all the functions for
us like I've previously done in ghidra.</p>
<p><img src="pdOS/./pd_sys_type_fail.png" alt="./pd_sys_type_fail.png" /></p>
<p>Excuse me tf. The endianness is wrong for the addresses :facepalm:. Joy.
Well I don't know how to fix that (after digging around a bit I couldn't figure it
out, not going to worry about it though since it doesn't really break anything and
you can manually add cross-references - the answer is probably defining a custom data
section that is big endian).</p>
<p>What we can do is manually create the references to all the functions, and manually
define functions at the necessary addresses (note because we are in thumb mode
when we create addresses at the odd addresses binary ninja will correctly create
the function at the odd address - 1, see <a href="https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings">here</a>
for computer engineers getting carried away). Cool let's look at realloc and see if it
worked:</p>
<p><img src="pdOS/./realloc_fail.png" alt="./realloc_fail" /></p>
<p>Ummm, great another bug. Failing to disassemble. Fantastic. After repo-ing ghidra, objdump,
capstone and ida, I'm thinking it's probably an issue with a hard float instructions (it
always is lmao). </p>
<p>The hard float abi used for this mcu is <a href="https://developer.arm.com/documentation/ddi0489/b/floating-point-unit/about-the-fpu">FPv5</a>.
So looks like we're going to need to make some MR's (or PR's in github land). yay.</p>
<p>See <a href="pdOS/./TriagingHardFloatDisassmbly.html">Triaging Hard Float Disassembly</a> for more.</p>
<p>In the mean time we can finish labelling all the functions and see where we stand.</p>
<p>Next: <a href="pdOS/./SearchingForFreeRTOSCode.html">Searching for FreeRTOS code</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="searching-for-freertos-code"><a class="header" href="#searching-for-freertos-code">Searching for FreeRTOS code</a></h1>
<p>So starting off, we know a couple things, we have a memory dump, and we know that the
processor is the <code>STM32F746IE</code>, which has internal flash range from <code>0x08000000</code> to
<code>0x080FFFFF</code> inclusive. We are able to dump flash starting at <code>0x08050000</code>, and we know
that the MPU is enabled. We are (currently) trying to figure out where the <code>FreeRTOS</code>
code is stored in the flash dump.</p>
<p>Let's see where some default FreeRTOS builds for ARM Cortex M7 put their code.
In the <code>FreeRTOS</code> source tree, the demo projects are in the path <code>demo/&lt;platform-info&gt;</code>,
so we'll see if we can find a couple <code>MPU</code> + <code>Cortex M7</code> projects and see if
they have attached linker scripts.</p>
<p>Bingo.</p>
<ul>
<li>
<p><a href="https://github.com/FreeRTOS/FreeRTOS/blob/main/FreeRTOS/Demo/CORTEX_MPU_M7_NUCLEO_H743ZI2_GCC_IAR_Keil/Projects/GCC/STM32H743ZITX_FLASH.ld">CORTEX_MPU_M7_NUCLEO_H743ZI2_GCC_IAR_Keil</a></p>
</li>
<li>
<p><a href="https://github.com/FreeRTOS/FreeRTOS/blob/main/FreeRTOS/Demo/CORTEX_M7_STM32F7_STM32756G-EVAL_IAR_Keil/System_IAR/stm32f756xx_flash.icf">CORTEX_M7_STM32F7_STM32756G-EVAL_IAR_Keil</a></p>
</li>
</ul>
<p>What we can guesstimate off of these (and the fact that we can read half the flash space)
is that the protected &quot;kernel&quot; code is in the first half, and that user mode is in the
second half of flash. Looking further at the linker scripts (the first one linked mainly),
we can see that they shove the syscalls at the beginning of the user flash region like so:</p>
<pre><code>  /* The program code and other data into &quot;FLASH&quot; Rom type memory */
  .text :
  {
    /* Place the FreeRTOS System Calls first in the unprivileged region. */
    . = ALIGN(4);
    __syscalls_flash_start__ = .;
    *(freertos_system_calls)
    __syscalls_flash_end__ = .;
    . = ALIGN(4);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;        /* define a global symbols at end of code */
  } &gt;FLASH
</code></pre>
<p>So we can probably just make a sample project for ourselves and then use the generated
<code>.map</code> listing files to see which syscalls are included and if any of the code looks similar.</p>
<p>Except, I'm lazy and I don't want to do it by hand. So we're going to attempt to make binary
ninja signatures with <a href="https://github.com/Vector35/sigkit/">sigkit</a> and go hunting for syscalls.</p>
<p>First though, we're going to do some basic recon:</p>
<p>From the <a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/bb6071e1df3168a64dc2ce79de8aa91b7995ba23/include/mpu_prototypes.h">MPU Syscalls</a> page:</p>
<blockquote>
<p>When the MPU is used the standard (non MPU) API functions are mapped to
equivalents that start &quot;MPU_&quot;, the prototypes for which are defined in this
header files.  This will cause the application code to call the MPU_ version
which wraps the non-MPU version with privilege promoting then demoting code,
so the kernel code always runs will full privileges.</p>
</blockquote>
<p>This sounds super jank lol, in an ideal secure world the user thread should not be getting promoted ever.
Here's to minimal os security woop woooppp</p>
<h3 id="grep--win"><a class="header" href="#grep--win">grep == win</a></h3>
<p>First I'm going to see if there are any <a href="https://developer.arm.com/documentation/dui0646/c/The-Cortex-M7-Instruction-Set/Miscellaneous-instructions/SVC">SVC</a>
invocations so we know what we're dealing with. To do that (instead of a cool way that is better like
a python script in binary ninja so we know what functions own the <code>svc</code> calls), we're going to
disassemble all of userspace bin, then <code>grep</code> for all the syscall instructions,
then trim down to the unique syscalls, and then count the lines.</p>
<pre><code class="language-bash">arm-none-eabi-objdump -D -b binary -marm -Mforce-thumb --adjust-vma=0x08050000 0x8050000_0x80fffff_playdate.bin | grep svc | sed -e&quot;s/;//p&quot; | awk '{$1=$1};1' | cut -d ' ' -f 4 | sort | uniq | wc -l
$ 66
</code></pre>
<p>So our kernel surface area is 66 syscalls, by default FreeRTOS ships with a couple depending on the platform, and has a ton pre-implemented (but not assigned to numbers afaics) so theres a lot of things going on here, cool. I'm assuming that
the pre-implemented syscalls are going to be lower numbers and any custom ones are descending starting from <code>0xff</code> (255).</p>
<p>Reminder of our goals here - we know that <a href="https://devforum.play.date/t/network-access-like-whitewater-wipeout-leader-boards/5598/2">only season games</a>
can use internet, and we can safely assume that there is some
functionality on board to do that - the only question is going to
be if that is exposed to games in userspace or if it is hidden
behind a syscall or completely handled in kernel space.</p>
<p>And we need find a way to automatically signature a bunch of
functions so we don't have to waste a bunch of time doing boring
RE. So we're going to build an example FreeRTOS project with
MPU enabled and all of the syscalls, then build signatures from
that and attempt to locate any code in our userspace dump.</p>
<h1 id="building-freertos"><a class="header" href="#building-freertos">Building FreeRTOS</a></h1>
<p>TODO</p>
<p><a href="https://github.com/FreeRTOS/FreeRTOS/blob/main/FreeRTOS/Demo/CORTEX_MPU_M7_NUCLEO_H743ZI2_GCC_IAR_Keil/Config/FreeRTOSConfig.h">Example <code>FreeRTOSConfig.h</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errata"><a class="header" href="#errata">Errata</a></h1>
<p>Random things required to actually RE the playdate.</p>
<p>thar be dragons here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triaging-hard-float-disassembly"><a class="header" href="#triaging-hard-float-disassembly">Triaging Hard Float Disassembly</a></h1>
<p>Anytime anyone tells you &quot;I had to look at [arbitrary compiler] source today&quot;,
that's a bad sign. It's like if someone told you they pooped today, what is
so wrong that there was a need to notify you that they pooped???</p>
<p>Well, I had to look at <code>gcc</code> source, and it's because disassembler's don't
support ARM FPv5 (note that gdb libopcode <a href="https://github.com/bminor/binutils-gdb/blob/master/opcodes/arm-dis.c#L1237">seem's to</a>
albeit associates this FPU version with ARMv8 - but at least there's that).</p>
<h1 id="what-is-arm-fpv5-and-why-does-this-matter"><a class="header" href="#what-is-arm-fpv5-and-why-does-this-matter">What is ARM FPv5 and why does this matter</a></h1>
<p>For the STM32F746IE MCU (our target processor), the Playdate uses FPv5
single-precision floating point support, therefore there are fancy
instructions that aren't supported that ruin all our disassembly.</p>
<h2 id="hard-vs-soft-float"><a class="header" href="#hard-vs-soft-float">Hard vs Soft Float</a></h2>
<p>They do the same math, except Hard float is implemented in <em>Hard</em> ware,
and Soft float is implemented in <em>Soft</em> ware. TLDR; Hard float is orders
of magnitude faster, at the cost of higher power consumption and a more
expensive MCU etc.</p>
<h2 id="fpv5-specification"><a class="header" href="#fpv5-specification">FPv5 Specification</a></h2>
<p><a href="https://developer.arm.com/documentation/ddi0403/latest">Architecture Reference Manual</a>
- chapter 6 is <strong>The Floating-point Instruction Set Encoding</strong></p>
<p><a href="https://developer.arm.com/documentation/dui0646/c/The-Cortex-M7-Instruction-Set/Floating-point-instructions">Floating Point Instructions</a></p>
<h1 id="wtf-are-they-doing-at-arm-and-can-i-have-some"><a class="header" href="#wtf-are-they-doing-at-arm-and-can-i-have-some">WTF are they doing at ARM (and can I have some)</a></h1>
<p>Primer: <a href="https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings">ARM mode vs. Thumb Mode</a></p>
<p>Primer: <a href="https://developer.arm.com/documentation/ka005091/1-0/?lang=en">What are FPU, VFP, ASE, NEON, MPE, SVE, SME, MVE, and VPU?</a></p>
<p>simd + neon + ase + mpe + vfp(v1 -&gt; v5) + vfp11 + mve can u just not, plz and ty.</p>
<h1 id="straight-to-the-gcc-source"><a class="header" href="#straight-to-the-gcc-source">Straight to the (gcc) source</a></h1>
<p><strong>&quot;why not just use the docs + libopcodes if they already support it&quot;</strong></p>
<p>Because sister, I have seen the beyond and I'm sick of the docs being different
from real life. That and an incorrect lifter is worse than an absent lifter.</p>
<p>So, I'm going to use the thing that emits the actual code to add <code>FPv5</code> support.</p>
<p>For science.</p>
<p>And because I hate myself.</p>
<h2 id="overview-of-gcc-source-tree"><a class="header" href="#overview-of-gcc-source-tree">Overview of gcc source tree</a></h2>
<p><a href="https://github.com/gcc-mirror/gcc">Source tree</a></p>
<ul>
<li>Top Level docs: <a href="https://gcc.gnu.org/onlinedocs/gccint/Top-Level.html#Top-Level">link</a></li>
<li>What we care about: <a href="https://gcc.gnu.org/onlinedocs/gccint/gcc-Directory.html#gcc-Directory">link</a>
<ul>
<li>specifically we want to know how a <code>gcc</code> backend is created (ie ARM)</li>
<li>note that a frontend is something like the C programming language, while the
backend is a platform / mcu architecture</li>
</ul>
</li>
</ul>
<h2 id="overview-of-a-gcc-backend"><a class="header" href="#overview-of-a-gcc-backend">Overview of a gcc backend</a></h2>
<p><a href="https://gcc.gnu.org/onlinedocs/gccint/Back-End.html#Back-End">GCC Backend docs</a></p>
<p>Of note:
&gt;A directory machine under gcc/config, containing a machine description machine.md file (see <a href="https://gcc.gnu.org/onlinedocs/gccint/Machine-Desc.html#Machine-Desc">Machine Descriptions</a>), header files machine.h and machine-protos.h and a source file machine.c (see <a href="https://gcc.gnu.org/onlinedocs/gccint/Target-Macros.html#Target-Macros">Target Description Macros and Functions</a>), possibly a target Makefile fragment t-machine (see <a href="https://gcc.gnu.org/onlinedocs/gccint/Target-Fragment.html#Target-Fragment">The Target Makefile Fragment</a>), and maybe some other files. The names of these files may be changed from the defaults given by explicit specifications in config.gcc.</p>
<p>We're mostly concerned with how instructions are emitted and what they look like, so we want to look at
the machine descriptions.</p>
<h2 id="overview-of-arm-gcc-backend"><a class="header" href="#overview-of-arm-gcc-backend">Overview of ARM gcc backend</a></h2>
<h2 id="how-does-gcc-do-arm-fpv5"><a class="header" href="#how-does-gcc-do-arm-fpv5">How does GCC do ARM FPv5</a></h2>
<p>Next: <a href="errata/./FPv5MeetWorld.html">FPv5 meet World</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fpv5-meet-world"><a class="header" href="#fpv5-meet-world">FPv5 meet world</a></h1>
<h1 id="opcode-patterns-from-the-docs"><a class="header" href="#opcode-patterns-from-the-docs">Opcode patterns from the docs</a></h1>
<p>Going through the <a href="https://developer.arm.com/documentation/ddi0403/latest">ARMv7M spec</a>
there are a few things we need to keep in mind:</p>
<h3 id="instruction-alignment--byte-ordering"><a class="header" href="#instruction-alignment--byte-ordering">Instruction alignment / byte ordering:</a></h3>
<p><img src="errata/./insn_alignment.png" alt="insn_alignment.png" /></p>
<p>The important bits are the <strong>&quot;byte at address <code>A + n</code>&quot;</strong></p>
<h3 id="when-reading-the-instruction-decodings-from-the-manual"><a class="header" href="#when-reading-the-instruction-decodings-from-the-manual">When reading the instruction decodings from the manual:</a></h3>
<p><img src="errata/./fpu_register_formats.png" alt="fpu_register_formats.png" /></p>
<h3 id="rude-syntax-flexibilities-to-make-things-oh-so-much-clearer"><a class="header" href="#rude-syntax-flexibilities-to-make-things-oh-so-much-clearer">Rude &quot;syntax flexibilities&quot; to make things oh so much clearer:</a></h3>
<p><img src="errata/./syntax_flexibilities.png" alt="syntax_flexiblities" /></p>
<h3 id="fpu-register-encoding"><a class="header" href="#fpu-register-encoding">FPU register encoding</a></h3>
<p><img src="errata/./fpu_register_encoding.png" alt="fpu_register_encoding" /></p>
<h1 id="opcode-patterns-from-gcc"><a class="header" href="#opcode-patterns-from-gcc">Opcode patterns from gcc</a></h1>
<h1 id="fpv5-meet-binary-ninja"><a class="header" href="#fpv5-meet-binary-ninja">FPv5 meet Binary Ninja</a></h1>
<h1 id="fpv5-meet-ghidra"><a class="header" href="#fpv5-meet-ghidra">FPv5 meet Ghidra</a></h1>
<h1 id="fpv5-meet-objdump"><a class="header" href="#fpv5-meet-objdump">FPv5 meet objdump</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
